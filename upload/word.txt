 арк докум підпис дата аркуш іалц 466530 003 зміст вступ розділ синтез топологічної організації вибір оригінальної топологічної організації математичний опис топології програмний опис топології визначення топологічних характеристик порівняння результатів характеристиками інших топологій відображення топології гіперкуб висновки розділу розділ алгоритми маршрутизації алгоритм маршрутизації one one алгоритм маршрутизації all all алгоритм маршрутизації one all personalized алгоритм маршрутизації one all personalized висновки розділу розділ завантаження задачі розроблену топологію опис алгоритму шифрування des реалізація шифрування завантаження задачі топологію висновки розділу висновки список використаних джерел додаток лістинг програмного забезпечення вступ сучасному світі комп’ютерні системи багатьма процесорами будуються основному основі гіперкубічної мешової топології оскільки вони визнані найбільш продуктивними ефективними метою курсового проекту дисципліни “проектування комп’ютерних систем” дослідження топології яка належить класів згаданим вище природно чистому вигляді жоден інший клас зміг зрівнятися наприклад гіперкубом проте гібридні комбінації можуть дозволити досягти високих показників ефективності для вибору топологічної організації дуже важливо розбиратися перевагах недоліках впливають продуктивність системи цілому даній роботі розглянуто модифіковане бінарне дерево кожен ярус якого з’єднаний двома кільцями першому розділі виконується аналіз даної топології різними характеристиками ступінь діаметр ціна порівняння іншими топологічними організаціями враховуючи існує безліч алгоритмів орієнтованих класичні топології виконано відображення гіперкуб другому розділі розглядається реалізація трьох видів маршрутизації one one all all one all personalized всі види маршрутизації жорстко пов’язаними топологією тобто них використовуються алгоритми дейкстри або флойда подібна вузька спеціалізація дозволяє оптимізувати часові витрати пересилання даних розроблений базовий набір програмного забезпечення лістинг якого можна знайти додатку третьому розділі виконано завантаження реальної задачі систему даною топологією якості задачі обраний алгоритм шифрування des який використовує перетворення допомогою мереж фейстеля саме перетворення дуже зручні для завантаження різні вершини топології синтез топологічної організації вибір оригінальної топологічної організації основою досліджуваної топології бінарне дерево зв’язку тим характеристики дерева зазвичай значно гірше ніж топологій типу меш решітка або гіперкуб дана топологія модифікована додаванням кілець кожному ярусі ярусі розташовані звичайне кільце так кільце “через один” забезпечує хорошу швидкість пересилання горизонтальному напрямку швидкість вертикального пересилання забезпечується структурою кластера якого верхня нижня вершини з’єднані кластер зображений рис рисунок кластер системи нумерація вузлів кластері виконується колу годинниковою стрілкою починаючи верхньої вершини надалі номери вершин кластері будуть називатися відносним індексом масштабування топології виконується шляхом додавання нового ярусу рис зображені топології рівнів відповідно рисунок система першому кроці масштабування рисунок система другому кроці масштабування рисунок система третьому кроці масштабування видно малюнків перших двох рівнях спостерігаються додаткові зв’язки кластерах кільцеві які даних рівнях з’єднують кластер фактично сам собою математичний опис топології створену топологію можна охарактеризувати математично так таблиці наведено матрицю суміжності для кластера таблиця матриця суміжності кластера алгоритм створення матриці інцидентності для топології наступний створюється матриця розміром n*n ініціалізувати список меж ярусу вигляді fifo черги виконується цикл для кожного кластера помістити матрицю інцидентності кластера вільний блок 6*6 діагоналі основної матриці зв’язати вершину відносним індексом вершиною отриманої списку меж ярусу помістити вершину відносним індексом списку меж ярусу для кожного ярусу виконати для кожного кластера ярусу виконати виконати кільцевий зв’язок вершини відносним індексом вершиною наступного кластера відносним індексом виконати кільцевий зв’язок вершини відносним індексом вершиною кластера слідує наступним відносним індексом програмний опис топології мові програмування java реалізація виглядатиме так public byte[][] topology final int numclusters int length cluster length int getp numclusters byte[][] matrix new byte[p][p] int offsetx offsety for int numcluster numcluster numclusters numcluster++ for int offsetx offsetx length i++ ii++ for int offsety offsety length j++ jj++ matrix[i][j] cluster[ii][jj] for int length i++ nodes add new node numcluster length numcluster detectlevel numcluster int edge numcluster length !edges isempty int parent edges removelast setlink matrix numcluster length parent edges addfirst edge edges addfirst edge offsetx length offsety length for int level numclusters i++ for int clustersinlevel j++ int numcluster numclusters int ring1 numcluster length int ring2 numclusters clustersinlevel length setlink matrix ring1 ring2 int doublering1 numcluster length int doublering2 numclusters clustersinlevel length setlink matrix doublering1 doublering2 for int matrix length i++ for int matrix[i] length j++ matrix[i][j] nodes get addedge nodes get return matrix визначення топологічних характеристик серед основних топологічних характеристик виберемо степінь діаметр середній діаметр топологічний трафік ціну системи степінь максимальне число дуг інцедентних вершині графі топології розраховується максимальна сума одиниць рядку або стовпці матриці суміжності діаметр мінімальна відстань між двома найбільш віддаленими процесорами мінімальна відстань між вузлами знаходиться допомогою алгоритму флойда уоршелла при цьому складається матриця відстаней між кожними вершинами потім шукається максимальне значення ній середній діаметр визначається формулою dij мінімальна відстань між двома процесорами топологічний трафік визначається формулою характеризує завантаженість ліній зв’язку ціна визначає вартість створення системи знаходиться формулою для визначення топологічних характеристик було написано програмне забезпечення яке було запущено різним параметром після чого було отримано інформацію про значення основних топологічних характеристик отримані результати були зведені табл таблиця основні характеристики системи обраною топологією кластерів 450 1470 4050 186 11160 378 30240 127 762 76200 255 1530 183600 511 3066 429240 1023 6138 982080 порівняння результатів характеристиками інших топологій для об’єктивної оцінки характеристик даної топології було виконано порівняння іншим подібним деревом його кластер аналогічний рис проте кроці масштабування система має вигляд рис порівняльний аналіз виконується наступним чином отримати дані про основні топологічні характеристики для різного розміру системи основі табличних даних побудувати графіки залежності степеню діаметру середнього діаметру ціни трафіку від кількості вершин загальний діапазон ділиться кілька середніх кількістю вимірів діапазонів обчислити середні нормалізовані значення кожної топологічної характеристики всіх діапазонах обчислити суму балів для кожного діапазону основі чого побудувати гістограму зробити висновки про ефективність роботи системи кожному діапазоні побудувати гістограму віддаленості від ідеалу різниця набраних балів мінімально можливої кількості балів нормалізація проводиться наступним чином степінь серед значень топологій для одного діапазону було вибрано мінімальне значення воно вважається оптимальним мінімальна степінь мінімальна ціна параметри топологій даному діапазоні поділені мінімальне значення діаметр аналогічно степені знайдено мінімальне значення нього поділені всі значення для даного діапазону середній діаметр аналогічно степені знайдено мінімальне значення нього поділені всі значення для даного діапазону ціна знайдено мінімальне значення нього поділені всі значення для даного діапазону трафік замість мінімального значення знайдено значення найбільш наближене оптимуму тобто нього поділені всі інші значення рисунок дерево для порівняння другому кроці масштабування топологічні характеристики цього дерева зібрані допомогою розробленого програмного забезпечення представлені табл таблиця основні характеристики системи топологією дерево 6667 1111 4872 2436 260 2814 6407 616 0606 0303 1188 8300 4150 2024 5923 7962 3172 3497 1748 4680 1031 5515 6596 118 8535 9268 8968 141 6016 3008 11844 166 3478 6739 15272 193 092 0462 19300 222 836 4179 23976 253 578 7890 29348 286 319 1596 35464 321 060 5299 42372 358 800 8998 50120 397 539 2695 58756 таблицями були побудовані графіки для порівняння різних топологічних характеристик результати відображені рис рисунок порівняння степенів рисунок порівняння діаметрів рисунок порівняння середніх діаметрів рисунок порівняння цін рисунок порівняння трафіків таблиця середні значення характеристик топології дерево інтервали 873975 529 4936 100 968775 4118 9844 100 400 20269 29542 6013 таблиця нормалізовані значення характеристик топології дерево інтервали віддаленість 71429 3784 179 4815 75324 75324 100 3612 492 7054 30857 30857 100 400 4917 4271 864 78286 78286 таблиця середні значення характеристик оригінальної топології інтервали 085 243 025 100 385 2760 100 400 20700 005 таблиця нормалізовані значення характеристик оригінальної топології інтервали віддаленість 06667 06667 06667 100 100 400 рисунок сумарна оцінка топологій зонах рисунок віддаленість топологій від ідеалу діапазонах відображення топології гіперкуб існують наступні методи для завантаження топологій гіперкуб звуження графу кілька ребер вихідного графу відображаються одне ребро стандартного недоліком методу збільшення трафіку розтягування графу ребро вихідного графу відображається допомогою кількох ребер стандартного недоліком зростання часу розширення графу цьому випадку одна вершина вихідного графу може відображатись допомогою кількох вершин стандартного даній роботі використовувалися другий третій методи топологія кроці масштабування зображена рис другого рис відображення цих топологій гіперкуб показано рис рисунок відображення топології рівня гіперкуб порядку рисунок відображення топології рівня гіперкуб висновки розділу цьому розділі була представлена оригінальна топологія заснована кластері зображеному рис завдяки характерним міжкластерним зв’язкам топологія дуже схожа класичне дерево було представлено можливість необмеженого масштабування топології збільшення кількості зв’язків пізніших кроках масштабування забезпечує стійкість відмов проте збільшує ціну топології рис очевидно недолік кластерів верхній ярус поєднаний нижнім допомогою лише одного дуального зв’язку для кожного кластера таким чином вихід ладу вершини відносним індексом суттєво вплине продуктивність системи вихід ладу безлічі таких вершин може зупинити роботу системи взагалі допомогою розробленого програмного забезпечення було визначено характеристики оригінальної топології дерева для різної кількості вузлів видно табл степінь фактично постійною величиною діаметр топології звичайний для організацій подібного роду середній діаметр менше середнього для класичних топологій ціна зростає експоненціально оскільки для розрахунків діаметр множиться кількість всіх ребер кількість всіх вершин сумі очевидно запропонована топологія виграє дерева всіх окрім степеню параметрах значно менше віддалена від ідеалу розділі також було проілюстровано відображення запропонованої топології гіперкуб алгоритми маршрутизації алгоритм маршрутизації one one алгоритм one one виконує пересилання даних вихідної вершини зазначену мінімальний час якості оцінки часу береться кількість переходів між вершинами тобто мається увазі час виконання одного переходу становить один такт досліджувана топологія представляє собою дерево тому маршрутизація легко розбивається процедури формалізований алгоритм для кожної вершини визначити наступні параметри індекс відносний індекс номер ярусу індекс кластера помістити покажчик початкову вершину виконати цикл якщо індекс покажчика збігається індексом одержувача вийти циклу якщо індекс кластера покажчика збігається індексом кластера отримувача виконати процедуру передачі кластері помістити покажчик результат якщо ярус покажчика збігається ярусом одержувача виконати процедуру передачі даних ярусу помістити покажчик результат якщо ярус покажчика більше ярусу одержувача виконати процедуру переходу кластеру для переміщення вершини кластері відносним індексом виконати перехід зовнішній кластер використовуючи вершину відносним індексом перемістити покажчик вершину отриману раніше якщо ярус покажчика менше ярусу одержувача виконати процедуру пошуку батьківського вузла для одержувача виконати процедуру переміщення ярусу вузла який вказує покажчик батьківського виконати процедуру переміщення кластеру вузла який вказує покажчик вершину того кластера відносним індексом виконати процедуру пошуку батьківських вузлів для одержувача використовуючи збільшений номер ярусу виконати перехід вузла якому покажчик батьківського присвоїти вказівнику результат отриманий минулому етапі алгоритм процедури пошуку батьківського вузла якщо ярус необхідної вершини збігається параметричним ярусом повернути вершину того кластера відносним індексом виконати цикл знайти внутрішній перехід кластер відносним індексом знайти зовнішній перехід кластер відносним індексом якщо ярус отриманої вершини збігається параметричним ярусом вийти циклу алгоритм процедури переміщення ярусу поки кластер покажчика збігається кластером одержувача виконати розрахувати відстань цільового кластера при русі вправо вліво якщо відстань вправо менше або дорівнює відстані вліво якщо відстань рівна виконати процедуру переміщення кластеру вершину відносним індексом виконати переміщення зовнішньому зв’язку вершини відносним індексом присвоїти вказівнику результат отриманий раніше якщо відстань більше виконати процедуру переміщення кластеру вершину відносним індексом виконати переміщення зовнішньому зв’язку вершину відносним індексом присвоїти вказівнику результат отриманий раніше якщо відстань вліво менше відстані вправо якщо відстань рівна виконати процедуру переміщення кластеру вершину відносним індексом виконати переміщення зовнішньому зв’язку вершину відносним індексом присвоїти вказівнику результат отриманий раніше якщо відстань більше виконати процедуру переміщення кластеру вершину відносним індексом виконати переміщення зовнішньому зв’язку вершину відносним індексом присвоїти вказівнику результат отриманий раніше алгоритм процедури переміщення кластеру запам’ятати початкову вершину покажчик виконати цикл якщо індекс покажчика дорівнює індексу цільової вершини вийти циклу якщо список сусідів покажчика містить цільову вершину виконати перехід присвоїти покажчику цільову вершину залежно від відносного індексу покажчика виконати дії якщо індекс дорівнює цільова вершина має відносний індекс має зв’язок перейти вершину відносним індексом якщо індекс дорівнює цільова вершина має відносний індекс має зв’язок перейти вершину відносним індексом якщо індекс дорівнює або виконати перехід вершину відносним індексом якщо індекс дорівнює цільова вершина має відносний індекс має зв’язок перейти вершину відносним індексом якщо індекс дорівнює цільова вершина має відносний індекс має зв’язок перейти вершину відносним індексом якщо індекс дорівнює або виконати перехід вершину відносним індексом наведемо приклад роботи алгоритму нехай необхідно передати повідомлення вузла вузол системі кроком масштабування sending from node #20 node #13 data arrived destination результат роботи відображено рис рисунок виконання алгоритму one one системі без відмов реалізація стійкості відмов зроблена допомогою модифікації кожної процедури випадок відмови якщо неможливо вибрати один шляхів програма знаходить обхідний шлях між двома точками приклад роботи вимкненою вершиною sending from node #20 node #13 data arrived destination результат роботи алгоритму зображено рис рисунок виконання алгоритму one one системі відмовою алгоритм маршрутизації all all алгоритм маршрутизації all all призначений для пересилки даних всіх вершин всім іншим топології враховуючи особливість деревовидної топології раціональніше всього відправляти дані ключові вершини які сполучними для різних кластерів при розсилці слід врахувати перед відсиланням даних треба запитати кінцевого вузла вони вже нього якщо вибрати іншу вершину можливих ідеальним варіантом поширення інформації була прогресія кроці дані отримує вузол кроці але можливо тільки при виконанні відправлення даних строго певних вершин графі реальності прогресія спадає кроці пов’язано ступенем топології при розробці даного алгоритму маршрутизації використовувався алгоритм one all формалізований алгоритм маршрутизації для кожної вершини виконати визначити відносний індекс вершини якої відправляються дані поки всі вершини отримали дані виконати скласти список вершин готових відправлення прибрати списку вершини яких всі сусіди отримали дані для кожної вершини списку виконати пересилання залежно від індексу якщо відносний індекс дорівнює переслати дані вище стоячому кластеру вершину відносним індексом для цього визначаються сусіди подібним індексом належать поточному кластеру якщо цільова вершина вже отримала дані вибрати вершину мінімальним індексом сусідніх вершин якщо відносний індекс дорівнює або переслати дані вершину відносним індексом даному кластері якщо цільова вершина вже отримала дані вибрати вершину мінімальним індексом сусідніх вершин якщо відносний індекс дорівнює переслати дані нижче стоячому кластеру вершину відносним індексом для цього визначаються сусіди подібним індексом належать поточному кластеру якщо доступно таких кластери вибирається вершина більшим індексом якщо цільова вершина вже отримала дані вибрати вершину максимальним індексом сусідніх вершин якщо відносний індекс дорівнює або переслати дані вершину відносним індексом даному кластері якщо цільова вершина вже отримала дані вибрати вершину максимальним індексом сусідніх вершин якщо список виконаних пересилань порожній топології недосяжні вершини тому треба передати інформацію про помилку номерами вершин які неможливо передати дані наведемо приклад роботи алгоритму для топології рівня масштабування якості кроку будемо рахувати всі пересилання виконуються паралельно оскільки відображення маршрутизації all all дуже громіздке для економії наведемо лише його частину наприклад розсилання даних вузла всім іншим інші передачі відбуваються аналогічним чином sending from node #16 step >15 step >14 step >13 >17 step >12 step >11 step >10 step step step all nodes received data рисунок виконання алгоритму one all системі без відмов нехай відмовили вершини тоді повідомлення відправляється шлях набуде вигляду зображеного рис оскільки відображення маршрутизації all all дуже громіздке для економії наведемо лише його частину наприклад розсилання даних вузла всім іншим інші передачі відбуваються аналогічним чином очевидно через відмову вузла весь перший кластер зміг отримати дані тому для систем такою топологією працездатність цих вузлів грає ключову роль sending from node #16 step >15 step >17 step >12 step >13 step >11 step step >10 step step nodes failed recieve data рисунок виконання алгоритму one all системі відмовами алгоритм маршрутизації one all personalized алгоритм маршрутизації one all personalized призначений для пересилання персоналізованих даних однієї вершини всім іншим топології фактично він базується алгоритмі one one але слід враховувати неможливо одночасно передавати кілька пакетів даних одному зв’язку тому кожна вершина повинна містити список пакетів кожному кроці відсилати одному кожний необхідний зв’язок цей список чергою тобто перший пакет прийшов повинен вилучатись нього також першим формалізований алгоритм маршрутизації наступний додати вершину відправник список активних вершин додати повідомлення для всіх вершин крім відправника повідомлення список списків пасивних сусідів додати сусідів вершини відправника поки вершини які отримали дані виконати якщо немає пасивних сусідів поточної активної вершини тоді видалити активних вершин поточну активну вершину списку пасивних сусідів видалити список належить поточній активній вершині інакше вибрати першу пасивну вершину оброблені вершини поточному рівні додати поточну активну вершину повідомлення видалити відправника всіх сусідів крім обраного передати повідомлення пасивній вершині список активних вершин наступного рівня додати пасивну вершину список списків пасивних сусідів додати сусідів пасивної вершини якщо немає пасивних сусідів поточної активної вершини тоді видалити активних вершин поточну активну вершину списку пасивних сусідів видалити список належить поточній активній вершині якщо всі вершини списку активних вершин містяться списку оброблених вершин тоді збільшити рівень список активних вершин додати всі вершини списку активних вершин наступного рівня очистити список активних вершин наступного рівня наведемо приклад роботи алгоритму для системи рівні масштабування рис відображено розсилання повідомлень відбувається вершини sending from node step step >12 step >17 >13 step >11 >10 >15 >14 >16 step step all nodes received data рисунок виконання алгоритму one all personalized системі без відмов алгоритм маршрутизації all one single node accumulation алгоритмі all one single node accumulation всі вузли одночасно відправляють повідомлення одержувачем якого один той вузол завдання яке вирішує даний алгоритм збір даних від усіх вузлів вузлі призначення для вирішення даної задачі можуть використовуватись декілька підходів перший них використання all all але даний підхід дуже неоптимальним врази програє наступному другий підхід використання паралельної роботи для всіх вузлів алгоритму one one даний підхід блокує певні вузли довгий час але зменшує кількість передач даних для оптимального вирішення даного завдання доцільно використовувати алгоритм one one для кожного вузла але акумулюванням пакетів від вузлів які повинні пройти через даний вузол припустимо підчас запуску all one всі вузли одночасно починають передавати дані вузол призначення так вузол одночасно може приймати передавати лише одному каналу зробимо припущення коли вузол вже приймає повідомлення всі іншим вузлам які намагаються передати йому пакет буде відповідати він занятий може прийняти повідомлення також припустимо кожен вузол періодично опитує своїх сусідів знає які них вийшли ладу кожен вузол намагається передати пакет вузлу сусіду найменшим значенням ідентифікатора формалізований алгоритм маршрутизації наступний всі вузли одночасно ініціюють пердачу пакетів вузлу отримувачу кожен вузлів вибирає для адресата пакета оптимальний перехід один сусідніх вузлів допомогою алгоритма one one якщо вузол вже приймає пакет позначимо його він відповідає всім вузлам які намагються передати йому дані він даний момент може прийняти пакет вузли які отримали повідомлення про зайнятість вузла акамулюють всі інші повідомлення які надходять при звільнені вузла він починає приймати дані від сусіда найменшим значенням ідентифікатора вузол який немає пакетів для передачі черга прийняття даних нього порожня завершує свою частину роботи даному алгоритмі приклад роботи алгоритму для цільова вершина також несправні вершини приклад роботи програми step m11 m15 m16 >17 m14 >13 step m13 m14 step m13 m17 step step m13 m14 m15 m16 m17 висновки розділу даному розділі розроблено три стійкі відмов алгоритми маршрутизації для запропонованої топології one one all all one all personalized маршрутизація даної топології тісно пов’язана синтезом складається двох частин між всередині кластера якості оцінки часу береться кількість переходів між вершинами алгоритм one one виконує пересилання даних початкової вершини зазначену мінімальний час алгоритм маршрутизації all all призначений для пересилки даних всіх вершин всім іншим топології при розробці даного алгоритму маршрутизації використовувався алгоритм one all алгоритм one all personalized призначений для передачі персоналізованих даних однієї вершини всім іншим топології фактично він базується алгоритмі one one але кожній вершині відправляються пакети різним вмістом недоліком представлених алгоритмів вони знаходять найкоротші шляхи той час перевагою значна стійкість відмов завантаження задачі розроблену топологію для завантаження систему топологією типу “дерево” добре підходять задачі мають яскраво виражені паралельні ділянки залежностями даних від результатів попередніх розрахунків дозволяє виконувати спуск дереву розділяти поточний етап виконання завдання дрібніші підзадачі подібний підхід часто використовується різних алгоритмах шифрування зокрема алгоритмі des опис алгоритму шифрування des des англ data encryption standard симетричний алгоритм шифрування даних розроблений 1970 80х часом набув міжнародного застосування даний алгоритм блоковим шифром щоб зрозуміти працює des необхідно розглянути принцип роботи блочного шифру прикладі мережі фейстеля вхідними даними для блочного шифру служать блок розміром біт бітний ключ виході після застосування шифрувального перетворення виходить бітний зашифрований блок причому незначні відмінності вхідних даних правило призводять істотної зміни результату блокові шифри реалізуються шляхом багаторазового застосування блоків вхідного тексту деяких базових перетворень серед цих базових перетворень виділяють складне перетворення одній локальній частині блоку просте перетворення між частинами блоку оскільки перетворення виконується блоках окремим кроком потрібно виконати поділ вхідних даних блоки необхідного розміру при цьому незалежно від формату вихідних даних текстові документи зображення або інші файли вони повинні бути перетворені бінарний вигляд тільки після цього розбиті блоки все вищезазначене може здійснюватися програмними так апаратними засобами перетворення мережею фейстеля перетворення над векторами блоками представляють собою ліву праву половини регістра зсуву алгоритмі des використовуються пряме перетворення мережею фейстеля при виконанні шифрування рис зворотне при дешифруванні рис рисунок пряме перетворення фейстеля рисунок зворотне перетворення фейстеля реалізація шифрування алгоритм роботи des дуже складний складається кількох етапів початкова перестановка цикли шифрування мережа фейстеля генерація ключів кінцева перестановка детальний алгоритм роботи des усіма необхідними перетвореннями наведено рис рисунок алгоритм des код шифрування мові java private static biginteger function biginteger right biginteger key int ind biginteger biginteger zero for int key testbit setbit ind else clearbit ind ind++ xor key biginteger[] new biginteger[8] biginteger[] new biginteger[8] for int b[i] biginteger zero for int j++ testbit b[i] b[i] setbit else b[i] b[i] clearbit shiftright int b[i] testbit a++ b[i] testbit int b[i] testbit b++ b[i] testbit b[i] testbit b[i] testbit bb[i] new biginteger string valueof s[i biginteger biginteger zero for int i++ for int bb[i] testbit setbit else clearbit shiftleft ind biginteger result biginteger zero for int key testbit result result setbit ind else result result clearbit ind ind++ return result завантаження задачі топологію етапи алгоритмі des можуть бути легко розпаралелені було виконано для даної топології завантаження задачі полягає наступному завантажити кореневій кластер вхідні дані виконати початкову перестановку виконати передачу даних алгоритмом one all personalized виконати другий етап шифрування вузлах системи передати дані для обчислення мережах фейстеля оскільки всередині мережі виконується багато операцій маючи достатню кількість вузлів також можна виконувати паралельно зібрати результат обчислення допомогою алгоритму one one виконати кінцеву перестановку вже було вказано розсилання даних виконується допомогою алгоритму one all personalized збір результату one one таким чином розпаралелювання дозволяє використовувати des декількох режимах для шифрування дешифрування або формування хешу необхідно навести приклад виконання задачі тобто промоделювати роботу алгоритму системі обраною топологією приймемо система має крок масштабування тобто вузлів вхідні дані вводяться вага пересилання дорівнює вага операції тоді початкове розсилання даних допомогою алгоритму one all personalized буде витрачено тактів початкову кінцеву перестановку паралельні обчислення багато часу витратиться послідовний збір результату алгоритмом one one пересилань довжиною такт передачі часом шлях довжиною три такти отже отримано результати сумарний час виконання 10 + також необхідно підрахувати час виконання послідовного варіанту програми 10*16 180 виходячи цього можна розрахувати коефіцієнти прискорення ефективності роботи системи отже коефіцієнт прискорення дорівнює коефіцієнт ефективності рівний висновки розділу для курсового проекту була вибрана задача виконання шифрування des дуже важливою для всіх областей пов’язаних криптографією перш все було наведено необхідні теоретичні відомості алгоритми для реалізації завантаження задачі систему використовувались алгоритми маршрутизації так початкове розсилання даних виконується допомогою алгоритму one all personalized збір результату one one дозволяє практиці перевірити працездатність для відправлення вхідних даних отримання проміжних фінальних результатів обчислень при завантаженні задачі систему оригінальною топологією було зроблено оцінку часу виконання алгоритму для конкретної розмірності також підраховані коефіцієнти прискорення ефективності отримані значення коефіцієнта прискорення коефіцієнта ефективності далекі від ідеальних можна пояснити значною кількістю передач даних при збільшенні розмірності задачі достатній пропускній здатності каналів частина програми може бути значно зменшена висновки ході виконання курсового проекту було розглянуто топологію основі бінарного дерева кожен ярус якого також подвійним кільцем також показано можливість необмеженого масштабування системи результатами порівняльного аналізу даної топологічної організації деревом було виявлено вона оптимальнішою сумі очевидно запропонована топологія виграє дерева всіх окрім степеню параметрах значно менше віддалена від ідеалу видно таблиць результатів степінь фактично постійною величиною діаметр топології звичайний для організацій подібного роду середній діаметр менше середнього для класичних топологій ціна зростає експоненціально для забезпечення сумісності алгоритмами розробленими для класичних систем виконано відображення даної топології гіперкуб топологія кроці масштабування розміщується гіперкубі порядку другому гіперкубі порядку подальший ріст схожий завантаженням звичайного бінарного дерева тобто порядок зростає пропорційно збільшенню рівня роботі розглянуто три види маршрутизації для даної топології one one all all one all personalized алгоритми вузькоспеціалізованими спрямованими швидку роботу саме даній топології маршрутизація даної топологічної організації тісно пов’язана синтезом складається двох частин між всередині кластера якості оцінки часу береться кількість переходів між вершинами недоліком представлених алгоритмів вони знаходять найкоротші шляхи той час перевагою значна стійкість відмов останньому розділі виконано завантаження задачі систему обраною топологією якості завдання було обрано алгоритм шифрування des при реалізації завантаження використовувалися алгоритми маршрутизації one all personalized для розсилки вхідних даних one one для збору проміжних фінального результатів при завантаженні задачі систему оригінальною топологією було зроблено оцінку часу виконання алгоритму для конкретної розмірності також підраховані коефіцієнти прискорення ефективності також ході роботи було розроблено програмне забезпечення для перевірки демонстрації роботи створених алгоритмів маршрутизації дослідження топологічних параметрів комп’ютерних систем програмне забезпечення розроблялося використанням платформи java недоліків використання можна віднести необхідність встановлення додаткового програмного забезпечення комп’ютер користувача проте перевагою даної методики перше платформа дозволяє запускати розроблений продукт будь якій операційні системі містить встановлений пакет jre друге дозволяє значно скоротити час розробки завдяки використання готових компонентів так для відображення графа обчислювальної системи було використано бібліотеку jgraphx список використаних джерел jgraphx [електронний ресурс] режим доступу публ https //github com/jgraph/jgraphx белов воробьев шаталов теория графов учебн пособие для вузов радио связь 1984 248 конспект лекцій курсу “проектування комп’ютерних систем” лектор луцький симметричные криптосистемы [електронний ресурс] режим доступу публ http //ru wikipedia org/wiki/симметричные криптосистемы хорстманн корнелл java библиотека профессионала том основы core java volume fundamentals изд вильямс 2008 816 с шифрование des [електронний ресурс] режим доступу публ http //habrahabr ru/post/99376/ эккель философия java thinking java изд спб питер 2003 976 нтуу «кпі» фіот 61м аркушів лит пояснювальна записка затвердив контр перевірив луцький розробив артемов іалц 466530 003 аркуш дата підпис докум арк